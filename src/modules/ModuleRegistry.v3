// Copyright 2023 Wizard Authors. All rights reserved.
// See LICENSE for details of Apache 2.0 license.

// Host modules must be registered by their name so the Wizard engine can find them.
component ModuleRegistry {
	private def map = Strings.newMap<(ImportProcessor, bool)>();

	def get(name: string) -> ImportProcessor {
		var t = map[name];
		return if(t.1, t.0);
	}
	def add(m: ImportProcessor, exposed: bool) {
		map[m.name] = (m, exposed);
	}
	def expose(glob: GlobMatcher) {
		for (l = Maps.keyList(map); l != null; l = l.tail) {
			var n = l.head;
			if (glob.matches(n)) map[n] = (map[n].0, true);
		}
	}
	def exposeOne(name: string) {
		var t = map[name];
		if (t.0 != null) map[name] = (t.0, true);
	}
}

// A memory module used for creating shared memories.
class MemoryModule extends ImportProcessor {
	new(name: string) super(name) { }
	def preprocess(module: Module, result: Array<Exportable>) {
		var imports = module.imports;
		for (j < imports.length) {
			var i = imports[j];
			if (!Strings.equal(this.name, i.imp.module_name)) continue;
			if (!Strings.equal("memory", i.imp.field_name)) continue;
			if (!MemoryDecl.?(i)) continue;
			result[j] = Target.newMemory(MemoryDecl.!(i));
		}
	}
}


// A host module (with state) that can provide imports to a module as well as the entrypoint and exit value.
class HostModule extends ImportProcessor {
	new(name: string) super(name) { }

	// Initializes the host module with the command-line arguments.
	def init(args: Array<string>, trace: bool, err: ErrorGen) { }
	// Get the main export and arguments, if exported from the instance.
	def getMain(instance: Instance) -> (Function, Array<Value>) { return (null, null); }
	// De-initialize after running.
	def deinit(result: Result) { }

	// Utility functions for subclasses.
	def getRegion(memory: Memory, v: Value, size: u32) -> i64 {
		if (memory == null) return -1;
		if (Value.I32.?(v)) return memory.boundsCheck(0, Value.I32.!(v).val, size);
		return -1;
	}
	def getRegion2(memory: Memory, v: u32, size: u32) -> i64 {
		if (memory == null) return -1;
		return memory.boundsCheck(0, v, size);
	}
	def getRegion3(memory: Memory, offset: Value, size: Value) -> MaybeTrap<Range<byte>> {
		if (memory == null) return MaybeTrap<Range<byte>>(null, TrapReason.NO_EXPORTED_MEM);
		match (offset) {
			I32(offset_u32) => match (size) {
				I32(size_u32) => return memory.range_ol_32(offset_u32, size_u32);
				I64(size_u64) => return memory.range_ol_64(offset_u32, size_u64);
				_ => ;
			}
			I64(offset_u64) => match (size) {
				I32(size_u32) => return memory.range_ol_64(offset_u64, size_u32);
				I64(size_u64) => return memory.range_ol_64(offset_u64, size_u64);
				_ => ;
			}
			_ => ;
		}
		return MaybeTrap<Range<byte>>(null, TrapReason.FAILED_CAST);
	}
	def copyString(memory: Memory, offset: Value, size: Value) -> MaybeTrap<string> {
		return getRegion3(memory, offset, size).then(Ranges.dup<byte>);
	}
}
